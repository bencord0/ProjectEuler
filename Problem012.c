/*
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
*/

#include <stdio.h>
#include <gmp.h>
#include "functions.h"

int count_divisors_of_triangular_num(const mpz_t nth);
int mpz_count_divisors(const mpz_t num);
int Problem012(void) {
	mpz_t test_triangle_no, n;
	int divisor_count;

	mpz_init(test_triangle_no);
	mpz_init_set_ui(n,1);

	while(1) {
		/*Generate*/
		mpz_triangular(test_triangle_no,n);
		/*Count*/
		divisor_count = count_divisors_of_triangular_num(n);

		/*Test*/
//		if(divisor_count>200)
//			gmp_printf("\t%Zd-%d\n",test_triangle_no,divisor_count);

		if(divisor_count>=500) {
			/*Succeed*/
			gmp_printf("%30Zd", test_triangle_no);
			break;
		}

		/*Fail and try again*/
		mpz_add_ui(n,n,1);
	}

	mpz_clear(test_triangle_no);
	mpz_clear(n);
	return 0;
}

/**
 * This is a general function to count divisors. It will work
 * for any integer.
 *
 * We can optimise. If sqrt(num) is also a divisor, there are
 * an odd number of divisors.
 * All divisors have pairs so we only need to check half of them.
 * ie. up to sqrt(num)
 */
int mpz_count_divisors(const mpz_t num) {
	int count=0;
	mpz_t div;
	mpz_t sqt;
	mpz_init(sqt);
	mpz_init(div);

	mpz_sqrtrem(sqt,div,num);
	if(!mpz_cmp_ui(div,0)){
		count--;
		if(/*div not num*/1) {}
	}

	mpz_set(div,sqt);
	do {
		if(mpz_divisible_p(num,div)){
			count++;count++;
		}
		mpz_sub_ui(div,div,1);
	} while(mpz_cmp_ui(div,0));

	mpz_clear(div);
	mpz_clear(sqt);

	return count;
}

/**
 * Let D(x) be the divisor count of x.
 * D(t) = D(n/2))*D(n+1) if n is even.
 * D(t) = D(n)*D( (n+1)/2 ) if n odd.
 * where t is the n'th triangular number.
 */
int count_divisors_of_triangular_num(const mpz_t nth) {
	int count;
	mpz_t n1, n2;
	mpz_init(n1);
	mpz_init(n2);

	if(mpz_even_p(nth)){
		mpz_divexact_ui(n1,nth,2);
		mpz_add_ui(n2,nth,1);

	} else {
		mpz_set(n1,nth);
		mpz_add_ui(n2,nth,1);
		mpz_divexact_ui(n2,n2,2);
	}

	count = mpz_count_divisors(n1) * mpz_count_divisors(n2);
	mpz_clear(n1);
	mpz_clear(n2);
	return count;
}
